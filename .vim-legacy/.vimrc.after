" *******************************************************
" } Source vimrc {
" *******************************************************
" Resource vimrc
noremap  <leader>s      :source $MYVIMRC<CR>
cnoreabbrev reload source $MYVIMRC


" *******************************************************
" } Function keys {
" *******************************************************
" Map F1 to the help
FnNoremap <F1>    :vert help<SPACE>


" *******************************************************
" } Sessions {
" *******************************************************
" Key mapping
FnNoremap <C-F9>    :mksession! ~/.vimsession<CR>
FnNoremap <F9>      :source! ~/.vimsession<CR>


" *******************************************************
" } Inline increment/decrement function {
" *******************************************************

" Increment/decrement numbers
FnNoremap <A-a>   <C-a>
FnNoremap <A-A>   <C-x>


" *******************************************************
" } Directory management {
" *******************************************************

" Look for the best root directory
function! g:FindRootDir()
	" Ctags/cscope files
	for file in ['g:tags_db', 'g:cscope_db']
		silent! let file=eval(file)
		let file = findfile(file, ".;")
		if (filereadable(file))
			return fnamemodify(file, ':p:h')
		endif
	endfor
	" SVN/GIT directory
	for dir in ['.svn', '.git']
		let _dir = finddir(dir, ".;", -1)
		if (!empty(_dir))
			return fnamemodify(_dir[-1], ':p:h:h')
		endif
	endfor
	" No match
	return ''    "'%:p:h:gs/ /\\ /'
endfunction

" Directory autochange
if 1
	if 0
		" Look for the best directory
		autocmd! BufEnter * execute "lcd" g:FindRootDir()
	elseif exists('+autochdir')
		" Automated directory change
		set autochdir
	else
		" Autocommand directory change
		augroup vimrc_autochdir
			autocmd! BufEnter * silent! lcd %:p:h:gs/ /\\ /
		augroup END
	endif
endif

" Change global directory to the current directory of the current buffer
nnoremap <silent><leader>c    :cd %:p:h<BAR>pwd<CR>

" Change global directory to the current directory of the current buffer
nnoremap <silent><leader>cd   :execute "cd " . g:FindRootDir()<BAR>pwd<CR>

" Change root directory once at startup
if !exists('g:loaded_vimrc')
	execute 'cd' g:FindRootDir()
endif


" *******************************************************
" } Hexadecimal display {
" *******************************************************
function! s:HexaToggle()
	if !exists('g:vimrc_hexa')
		exec ":%!xxd"
		let g:vimrc_hexa=1
	else
		exec ":%!xxd -r"
		unlet g:vimrc_hexa
	endif
endfunction

" Key mapping
map <leader>hh :call <SID>HexaToggle()<CR>
map <leader>h  :%!xxd<CR>
map <leader>H  :%!xxd -r<CR>


" *******************************************************
" } Alignment function {
" *******************************************************
" Alignement function
function! s:AlignStatement()
	" Patterns needed to locate assignment operators...
	let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
	let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)'

	" Locate block of code to be considered (same indentation, no blanks)
	let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
	let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
	let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
	if lastline < 0
		let lastline = line('$')
	endif

	" Find the column at which the operators should be aligned...
	let max_align_col = 0
	let max_op_width  = 0
	for linetext in getline(firstline, lastline)
		" Does this line have an assignment in it?
		let left_width = match(linetext, '\s*' . ASSIGN_OP)

		" If so, track the maximal assignment column and operator width...
		if left_width >= 0
			let max_align_col = max([max_align_col, left_width])
			let op_width      = strlen(matchstr(linetext, ASSIGN_OP))
			let max_op_width  = max([max_op_width, op_width+1])
		 endif
	endfor

	" Code needed to reformat lines so as to align operators...
	let FORMATTER = '\=printf("%-*s%*s", max_align_col, submatch(1),
	\                                    max_op_width,  submatch(2))'

	" Reformat lines with operators aligned in the appropriate column...
	for linenum in range(firstline, lastline)
		let oldline = getline(linenum)
		let newline = substitute(oldline, ASSIGN_LINE, FORMATTER, "")
		call setline(linenum, newline)
	endfor
endfunction

" User commands
command! -nargs=0 -bar AlignStatement      :call <SID>AlignStatement()

" Key mapping
map <leader>=   :AlignStatement<CR>


" *******************************************************
" } Diff {
" *******************************************************
" Options
set diffopt=vertical,filler,context:4

" Color scheme
highlight DiffAdd cterm=none ctermfg=bg ctermbg=Green gui=none guifg=bg guibg=Green
highlight DiffDelete cterm=none ctermfg=bg ctermbg=Red gui=none guifg=bg guibg=Red
highlight DiffChange cterm=none ctermfg=bg ctermbg=Yellow gui=none guifg=bg guibg=Yellow
highlight DiffText cterm=none ctermfg=bg ctermbg=Magenta gui=none guifg=bg guibg=Magenta

" Key mapping
noremap <localleader>d      :diffthis<CR>
noremap <localleader>dd     :diffthis<BAR>vsp<CR>
noremap <localleader>ds     :diffsplit<SPACE>
noremap <localleader>dc     :diffoff!<CR>
noremap <localleader>du     :diffupdate<CR>
FnNoremap <silent><F8>      [c
FnNoremap <silent><S-F8>    ]c
nnoremap <silent>h          [c<CR>
nnoremap <silent>H          ]c<CR>


" *******************************************************
" } Formatting {
" *******************************************************
" Indentation normal & visual modes
nnoremap <Tab>      >>
vnoremap <Tab>      >
nnoremap <S-Tab>    <LT><LT>
vnoremap <S-Tab>    <LT>

" Identation insert mode
"inoremap <Tab>   <C-T>
"inoremap <S-Tab> <C-D>

" Y behave like C and D (not like cc, dd, yy)
noremap Y y$

" Word quote
nnoremap <silent> <leader>" viw<esc>a"<esc>hbi"<esc>lel

" Upper/lower case
vnoremap <C-u>      U
vnoremap <C-l>      L

" *******************************************************
" } Statusline {
" *******************************************************
if !exists('g:loaded_airline')

	" Returns "mixed" when indentation is mixed
	function! b:StatuslineWarning()
		if !exists("b:statusline_tab_warning")
			let tabs = search('^\t', 'nw')
			let spaces = search('^ \+[^\*]', 'nw')
			if tabs && spaces
				let b:statusline_tab_warning =  '-mixed '.(&et ? tabs : spaces)
			elseif (spaces && !&et) || (tabs && &et)
				let b:statusline_tab_warning = '-error'
			else
				let b:statusline_tab_warning = ''
			endif
		endif
		return b:statusline_tab_warning
	endfunction

	" Set global status line content
	function! s:StatuslineGlobal()
		if has("statusline") && &modifiable
			"if exists('g:loaded_buftabs')
			"	set statusline=\ %{buftabs#statusline(-45)}
			"else
			"	set statusline=[%n]\ %<%F
			"endif
			set statusline=\ %{exists('g:loaded_buftabs')?buftabs#statusline(-45):'[%n]\ %<%F'}
			set statusline+=\ %=
			set statusline+=\ [%{strlen(&fenc)?&fenc:'none'},%{&ff}]%h%m%r
			set statusline+=\ [%{&expandtab==0?'tabs':'space'}%{b:StatuslineWarning()}]
			set statusline+=\ %y\ %c,%l/%L\ %P
		endif
	endfunction

	" Hide status line
	function! s:StatusLineHide()
		hi StatusLine ctermbg=NONE ctermfg=white
		hi clear StatusLine
		set laststatus=0
	endfunction

	" Line options
	set laststatus=2                " Always show status line

	" User command
	command! -range=% -nargs=0 StatuslineGlobal call <SID>StatuslineGlobal(<f-args>)

	" Update the warning flag
	autocmd cursorhold,bufwritepost * unlet! b:statusline_tab_warning

	" Key mapping
	noremap <silent><localleader>s  :call <SID>StatuslineGlobal()<CR>

	" Set the status line once
	if !exists("g:loaded_vimrc")
		call s:StatuslineGlobal()
	endif

endif


" *******************************************************
" } Space to tabs / tab to spaces {
" *******************************************************

" Tab to space
function! s:Tab2Space() range
	let firstline = a:firstline == a:lastline ? 0 : a:firstline
	let lastline = a:firstline == a:lastline ? line('$') : a:lastline
	execute ':'.firstline.','.lastline.'s#^\t\+#\=repeat(" ", len(submatch(0))*' . &ts . ')'
endfunction

" Space to tab
function! s:Space2Tab() range
	let firstline = a:firstline == a:lastline ? 0 : a:firstline
	let lastline = a:firstline == a:lastline ? line('$') : a:lastline
	execute ':'.firstline.','.lastline.'s#^\( \{'.&ts.'\}\)\+#\=repeat("\t", len(submatch(0))/' . &ts . ')'
endfunction

" Intelligent tab to spaces
function! s:Tabfix() abort
	if &expandtab==0
		call s:Tab2Space()
	else
		call s:Space2Tab()
	endif
	update
	YAIFAMagic
endfunction

" User commands
command! -range=% -nargs=0 Tab2Space call <SID>Tab2Space()
command! -range=% -nargs=0 Space2Tab call <SID>Space2Tab()
command! -range=% -nargs=0 Tabfix    call <SID>Tabfix()

" Key mapping
noremap <leader><Tab> :call <SID>Tabfix()<CR>


" *******************************************************
" } Space & tabs highlight {
" *******************************************************

" Show unwanted extra white space and tab characters
if !exists('s:spaceTabHighlight')
	let s:spaceTabHighlight = 0
endif

" Highlight unwanted space and tabs
function! s:SpaceTabHighlight(switchOn)
	if a:switchOn == 1
		" Set color
		hi ExtraWhitespace ctermbg=darkgreen guibg=darkgreen
		hi ExtraTabs ctermbg=darkgreen guibg=darkgreen
		" Show trailing spaces and spaces before a tab
		syn match ExtraWhitespace /\s\+$\| \+\ze\t/
		if &expandtab==0
			" Show spaces wrongly used for indenting
			" Show tabs that are not at the start of a line
			syn match ExtraTabs /^\t*\zs \+\|[^\t]\zs\t\+/
		else
			" Show tabs that are not at the start of a line
			syn match ExtraTabs /[^\t]\zs\t\+/
		endif
	else
		" Enable syntax back
		syn on
	endif
endfunction

" Highlight unwanted space and tabs
function! s:SpaceTabToggle()
	let s:spaceTabHighlight = !s:spaceTabHighlight
	call <SID>SpaceTabHighlight(s:spaceTabHighlight)
endfunction

" Key mapping
map <silent><localleader>v  :call <SID>SpaceTabToggle()<CR>


" *******************************************************
" } Search {
" *******************************************************
set ignorecase      " Case-insensitive search
set smartcase       " Unless search contain upper-case letters
set incsearch       " Show the `best match so far' when search is typed
set nogdefault      " Assume /g flag (replace all) is NOT set

" Highlight current selection
function! s:SearchHighlight()
	let old_reg=getreg('"')
	let old_regtype=getregtype('"')
	execute "normal! gvy"
	let @/=substitute(escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')
	execute "normal! gV"
	call setreg('"', old_reg, old_regtype)
	set hls
endfunction

" Toggle search highlighting
nnoremap <localleader><F3>  :set invhls hls?<CR>
nnoremap <localleader>f     :set invhls hls?<CR>

" Search
FnNoremap <C-f>     /
"FnNoremap <C-f>     yiw:/<C-r>"
"FnNoremap <C-f>     :/<C-r><C-w>
"vnoremap <C-f>      "+y:/<C-r>"
vnoremap <C-f>      "+y:/<C-r>=substitute(escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR>
cnoremap <C-f>      <NOP> |" Disable command line window (use q: q/ q? instead)

" F3 for search (n and N)
FnNoremap <F3>      n
FnNoremap <S-F3>    N
FnNoremap <C-F3>    :nohl<CR>
vmap <S-F3>         <F3>N
vnoremap <F3>       :<C-u>call <SID>SearchHighlight()<CR>
vnoremap <C-F3>     :nohl<CR>

" Alternative search
nnoremap f          n
nnoremap F          N

" F4 for select & search (* and #)
FnNoremap <F4>      *
FnNoremap <S-F4>    #
nnoremap µ          #


" *******************************************************
" } Find files {
" *******************************************************
" Find files
function! s:FindFiles(files, ...)
	let path  = escape(g:FindRootDir().'/'.a:files, '" *')
	execute 'Wsys' '_ffind' path join(a:000)
endfunction

" Abbreviations
cnoreabbrev ff FindFiles

" User commands
command! -nargs=+ -bar FindFiles call <SID>FindFiles(<f-args>)

" Keymapping
FnNoremap <C-f><C-f>   :FindFiles<SPACE>
"vnoremap <C-f><C-f>    "+y:FindFiles <C-R>"
vnoremap <C-f><C-f>    "+y:FindFiles<SPACE><C-r>=fnameescape("<C-r>"")<CR>


" *******************************************************
" } Sed & replace {
" *******************************************************
" Sed (replace in files)
function! s:Sed(pattern, replace, files, ...)
	let path  = '"'.escape(g:FindRootDir().'/'.a:files, ' ').'"'
	let expr1 = '"'.escape(a:pattern, '" *').'"'
	let expr2 = '"'.escape(a:replace, '" *').'"'
	execute '!_fsed' join(a:000) expr1 expr2 path
endfunction

" User commands
command! -nargs=+ -bar Sed  call <SID>Sed(<f-args>)

" Sed keymapping
FnNoremap <C-h><C-h>   :Sed<SPACE>
"vnoremap <C-h><C-h>    "+y:Sed <C-R>"
vnoremap <C-h><C-h>    "+y:Sed <C-r>=fnameescape("<C-r>"")<CR>

" Replace keymapping
FnNoremap <C-h>     :%s///cg<left><left><left><left>
"FnNoremap <C-A-h>    yiw:%s/<C-R>"/<C-R>"/cg<left><left><left>
"vnoremap  <C-h>      "+y:%s/<C-R>"/<C-R>"/cg<left><left><left>
"vnoremap  <C-A-h>    "+y:%s/<C-R>"//cg<left><left>
"vnoremap <C-h>       "+y:%s/<C-r>=fnameescape("<C-r>"")<CR>/<C-r>=fnameescape("<C-r>"")<CR>/cg<left><left><left>
vnoremap <C-h>      "+y:%s/<C-r>=substitute(escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR>/<C-r>=escape(@", '/\.*$^~[&')<CR>/cg<left><left><left>


" *******************************************************
" } Grep {
" *******************************************************
" Grep program
set grepprg=iref\ $*
"set grepprg=lid\ -Rgrep\ -s
"set grepformat=%f:%l:%m

" Abbreviations
cnoreabbrev gg Grep
cnoreabbrev grep Grep

" Grep
function! s:Grep(path, expr)
	let path = escape(a:path, '" *')
	let expr = escape('"'.a:expr.'"','" *')
	execute 'Wcmd' 'grep!' expr path
	silent! Wfirst
endfunction

" Count expression
function! s:GrepCount(path, expr)
	let path = escape(a:path, '" *')
	let expr = escape('"'.a:expr.'"','" *')
	execute '!ref' expr path '| wc -l'
endfunction

" User commands
command! -nargs=1 -bar RGrep      call <SID>Grep(g:FindRootDir(), <q-args>)
command! -nargs=1 -bar RGrepCount call <SID>GrepCount(g:FindRootDir(), <q-args>)
command! -nargs=1 -bar Grep      call <SID>Grep(expand('%'), <q-args>)
command! -nargs=1 -bar GrepCount call <SID>GrepCount(expand('%'), <q-args>)

" Key mappings
silent! unmap gx
nnoremap <silent>g          :Wnext<CR>
nnoremap <silent>G          :Wprev<CR>
" RGrep key mappings
FnNoremap <C-g>             :Grep<SPACE>
vnoremap <C-g>              "+y:Grep<SPACE><C-r>=fnameescape("<C-r>"")<CR>
FnNoremap <A-g>             :GrepCount<SPACE><C-r><C-w>
" Grep key mappings
FnNoremap <C-g><C-g>        :RGrep<SPACE>
vnoremap <C-g><C-g>         "+y:RGrep<SPACE><C-r>=fnameescape("<C-r>"")<CR>
FnNoremap <A-g><A-g>        :RGrepCount<SPACE><C-r><C-w>

" Hints to copy paste inside the key map
"FnNoremap <C-g>             :Grep<SPACE><C-r><C-w>
"vnoremap <C-g>              "+y:Grep<SPACE><C-r>"
"vnoremap <C-g>              "+y:Grep<SPACE><C-r>=fnameescape("<C-r>"")<CR>


" *******************************************************
" } Make {
" *******************************************************
" Make program
"set makeprg=make\ $*
"set makeformat=%f:%l:%m

" Abbrevations
"cnoreabbrev make lmake

" Fix make errors encoding
function! QfRemoveAnsiColor()
	let qflist = getqflist()
	for i in qflist
		"let i.text = iconv(i.text, "cp936", "utf-8")
		let i.text = substitute(i.text, "\e[\d+;\d+m", "", "g")
	endfor
	call setqflist(qflist)
endfunction

" Autocommands
if has('quickfix')
	autocmd! QuickfixCmdPost make call QfRemoveAnsiColor()
endif


" *******************************************************
" } Cursor management {
" *******************************************************
" Highlight cursor line/column
noremap <localleader>h   :set cursorline!<CR>
noremap <localleader>hh  :set cursorcolumn!<CR>

" Show line number
map <localleader>n  :set nu!<CR>

" Jump to line
FnNoremap  <C-j> :
vnoremap <C-j>  <C-c>:

" Prev/next cursor location
" Note: <C-[> is Esc, <C-c> exits visual mode
FnNoremap <A-Left>  <C-O>
FnNoremap <A-Right> <C-I>
vnoremap <A-Left>   <C-c><C-O>
vnoremap <A-Right>  <C-c><C-I>


" *******************************************************
" } Tab management {
" *******************************************************
" Options
if exists('g:vimrc_useTabs')
	silent! set switchbuf=usetab,newtab  " Buffer switch
endif
if exists('+gtl') " Tab name is the filename only
	set gtl=%t
endif

" Open/close tab
FnNoremap <C-t>        :tabnew<CR>
FnNoremap <C-t><C-t>   :tabe<SPACE>
FnNoremap <C-t><C-c>   :tabclose<CR>
if exists('g:vimrc_useTabs')
	FnNoremap <C-F4>     :tabclose<CR>
	FnNoremap <C-S-F4>   :tabdo tabclose<CR>
endif

" Prev/next tab
if exists('g:vimrc_useTabs')
	FnNoremap <C-Tab>    :tabn<CR>
	FnNoremap <C-S-Tab>  :tabp<CR>
else
	FnNoremap <C-PgUp>   :tabn<CR>
	FnNoremap <C-PgDown> :tabp<CR>
endif

" Autocommands
if exists('g:vimrc_useTabs')
	if (&diff==0) " no in diff mode
		" Open in tab allways
		augroup vimrc_tab
			autocmd! BufReadPost * tab ball
		augroup END
	endif
endif


" *******************************************************
" } Window management {
" *******************************************************
" Open/close window : standard mappings <C-w>...
" Prev/next window (Ctrl-w/W)

" Go up/down/left/right window
FnNoremap <C-Up>      :wincmd k<CR>
FnNoremap <C-Down>    :wincmd j<CR>
FnNoremap <C-Left>    :wincmd h<CR>
FnNoremap <C-Right>   :wincmd l<CR>

" Resize current window by +/- 5
" Same as 5<C-w>+  5<C-w>-  5<C-w>>  5<C-w><
"nnoremap <C-w><left>   :vertical resize -5<cr>
"nnoremap <C-w><right>  :vertical resize +5<cr>
"nnoremap <C-w><up>     :resize -5<cr>
"nnoremap <C-w><down>   :resize +5<cr>

" Extend window through the splits...
" Same as <C-w>_  <C-w>|
"noremap <C-J>  <C-w>j<C-w>_
"noremap <C-K>  <C-w>k<C-w>_
"noremap <C-H>  <C-w>h<C-w>\|
"noremap <C-L>  <C-w>l<C-w>\|

" Exit to normal when changing windows
augroup exit_to_normal
	autocmd! WinEnter * stopinsert
augroup END

" Zoom In/out window
function! s:ZoomWnd() abort
	if exists('s:zoomWndFlag')
		execute s:zoomWndFlag
		unlet s:zoomWndFlag
		au! ZoomWnd
	else
		let s:zoomWndFlag = winrestcmd()
		"vert resize
		wincmd _
		wincmd |
		augroup ZoomWnd
			au! WinLeave * call s:ZoomWnd()
		augroup END
	endif
endfunction

" Toggles window max/equal
function! s:ToggleWndMax()
	if exists('s:wndMaxFlag')
		execute s:wndMaxFlag
		unlet s:wndMaxFlag
		au! maxCurrWin
	else
		let s:wndMaxFlag = winrestcmd()
		do maxCurrWin WinEnter
		augroup maxCurrWin
			au! WinEnter * wincmd _ | wincmd |
		augroup END
	endif
endfunction

" Key maps
nnoremap <localleader>w     :call <SID>ToggleWndMax()<CR>
nnoremap <localleader>x     :call <SID>ZoomWnd()<CR>


" *******************************************************
" } Buffer management {
" *******************************************************
" Close buffer
function! s:BufClose(...)
	let idx = (a:0 ? a:1 : '')
	if exists(':Bdelete')
		execute 'silent! Bdelete' idx
	elseif exists(':MBEbd')
		execute 'MBEbd' idx
	else
		execute 'bdelete' idx
	endif
endfunction

" Close buffers with given extension
function! s:BufCloseByExt(ext)
	let last = bufnr('$')
	let idx = 1
	while idx <= last
		if bufexists(idx) && bufname(idx) =~ a:ext.'$'
			execute 'BufClose' idx
		endif
		let idx = idx + 1
	endwhile
endfunction

" Cycle through each buffer, ask to close
function! s:BufCloseAll(...)
	let last = bufnr('$')
	let idx = 1
	while idx <= last
		if bufexists(idx) && getbufvar(idx, '&modifiable')
			if (a:0 && !a:1) || confirm("Close buffer '".bufname(idx)."'?", "&yes\n&no", 1)==1
				execute 'BufClose' idx
			endif
		endif
		let idx = idx + 1
	endwhile
endfunction

" Intelligent open related buffer
let s:vimrc_bufopenext = ['h','cc','c']
function! s:BufSmartOpen()
	for file in ['<cfile>', '%']
		" Skip non-existent files
		if !filereadable(expand(file))
			continue
		endif
		" Try few extensions
		for ext in s:vimrc_bufopenext
			" Search in the same directory
			let open_file = expand(file.":r") . '.' . ext
			if open_file!=?expand("%") && filereadable(open_file)
				silent! execute ':e' fnameescape(open_file)
				return
			endif
			" Search with tags and cscope
			let open_file = expand(file.":t:r") . '.' . ext
			if open_file!=?expand("%:t")
				silent! execute "tag" open_file | return
				if has('cscope')
					set nocscopeverbose
					execute "cs f f" open_file | return
					set cscopeverbose
				endif
			endif
		endfor
	endfor
endfunction

" User commands
command! -nargs=? BufClose call s:BufClose(<f-args>)
command! -nargs=1 BufCloseByExt call s:BufCloseByExt(<f-args>)
command! -nargs=? BufCloseAll   call s:BufCloseAll(<f-args>)
command! -nargs=0 BufSmartOpen  call s:BufSmartOpen()

" Open/close buffer (close=:bd or :bw)
FnNoremap <C-b>       :e<SPACE><C-R>=expand("%:p:h") . "/" <CR>
FnNoremap <C-b><C-b>  :BufSmartOpen<CR>
FnNoremap <C-b><C-c>  :BufClose<CR>
FnNoremap <C-q>       :BufClose<CR>
if !exists("g:vimrc_useTabs")
	FnNoremap <C-F4>    :BufClose<CR>
	FnNoremap <C-S-F4>  :BufCloseAll 1<CR>
endif

" Prev/next buffer
FnNoremap <C-b><C-n>  :bn<CR>
FnNoremap <C-b><C-p>  :bp<CR>
FnNoremap <A-Down>    :bp<CR>
FnNoremap <A-Up>      :bn<CR>
if mapcheck('<C-Tab>')==''
	FnNoremap <C-Tab>   :bn<CR>
	FnNoremap <C-S-Tab> :bp<CR>
endif

" Wide empty buffer at startup
if bufname('%') == ''
	set bufhidden=wipe
endif


" *******************************************************
" } Marks {
" *******************************************************

" Marks variables
if !exists("s:mark_next")
	let s:mark_cur=0
	let s:mark_next=0
	let s:mark_max=1
endif

" Set a mark
function! s:MarkSet()
	if &buftype!=#'quickfix' && !&pvw
		exec printf("ma %c", 65 + s:mark_next)
		let s:mark_cur=s:mark_next
		let s:mark_next=(s:mark_next + 1) % 26
		let s:mark_max=max([s:mark_next,s:mark_max])
	else
		execute "normal! \<ENTER>"
	endif
endfunction

" Goto next mark
function! s:MarkNext()
	let s:mark_cur=(s:mark_cur + 1) % s:mark_max
	silent! exec printf("normal '%c", 65 + s:mark_cur)
endfunction

" Goto prev mark
function! s:MarkPrev()
	let s:mark_cur=(s:mark_cur + s:mark_max - 1) % s:mark_max
	silent! exec printf("normal '%c", 65 + s:mark_cur)
endfunction

" Reset all user marks
function! s:MarkReset()
	delmarks A-Z0-9
endfunction

" User commands
command! -nargs=0 -bar Mset   call <SID>MarkSet()
command! -nargs=0 -bar Mnext  call <SID>MarkNext()
command! -nargs=0 -bar Mprev  call <SID>MarkPrev()
command! -nargs=0 -bar Mreset call <SID>MarkReset()

" Mark key maps
FnNoremap <silent><F2>    :Mnext<CR>
FnNoremap <silent><S-F2>  :Mprev<CR>
FnNoremap <silent><C-F2>  :Mset<CR>
FnNoremap <silent><A-F2>  :Mreset<CR>
nmap <silent>m            :Mprev<CR>
nmap <silent>M            :Mnext<CR>
nmap <silent><C-m>        :Mset<CR>
nmap <silent><A-m>        :Mreset<CR>


" *******************************************************
" } Generic tag window management {
" *******************************************************
" Default windows
let g:wdefault = 'c'

" Select the right action list based on the current context
function! s:Wprefix()
	return (&previewwindow ? 'p' : (&buftype==?"quickfix" ? s:Qtype() : g:wdefault))
endfunction

" Search next
function! s:Wnext(prefix)
	try | silent execute a:prefix . "next" | catch | silent! execute a:prefix . "first" | endtry
endfunction

" Search prev
function! s:Wprev(prefix)
	try | silent execute a:prefix . "prev" | catch | silent! execute a:prefix . "last" | endtry
endfunction

" Execute system commands in quickfix or location window
function! s:Wsys(prefix, ...)
	execute a:prefix . "getexpr system('" . escape(join(a:000),"\"") . "')"
endfunction

" Execute vim commands in quickfix or location window
function! s:Wcmd(prefix, ...)
	execute (a:prefix==?'c' ? "" : a:prefix) . join(a:000)
endfunction

" User commands
command! -nargs=0 -bar Wopen    execute toupper(s:Wprefix()).'open'
command! -nargs=0 -bar Wclose   execute toupper(s:Wprefix()).'close'
command! -nargs=0 -bar Wtoggle  execute toupper(s:Wprefix()).'toggle'
command! -nargs=0 -bar Wfirst   execute s:Wprefix().'first'
command! -nargs=0 -bar Wlast    execute s:Wprefix().'last'
command! -nargs=0 -bar Wnext    execute toupper(s:Wprefix()).'next'
command! -nargs=0 -bar Wprev    execute toupper(s:Wprefix()).'prev'
command! -nargs=+ -bar Wsys     call s:Wsys(g:wdefault,<f-args>)
command! -nargs=+ -bar Wcmd     call s:Wcmd(g:wdefault,<f-args>)

" Generic keymapping
noremap <silent><C-SPACE>       :Wtoggle<CR>
nnoremap <silent><SPACE>        :Wnext<CR>
nnoremap <silent><S-SPACE>      :Wprev<CR>


" *******************************************************
" } Quickfix window management {
" *******************************************************
" Find if the given buffer is quickfix or location
function! s:Qtype(...)
	return (&buftype==?"quickfix" ? (exists("w:quickfix_title") && w:quickfix_title[1]==?"l" ? "l" : "c") : "")
"  let bufselect = (a:0 ? a:1 : '%')
"  if (!empty(bufselect) && getbufvar(bufselect,'&buftype')!=?"quickfix")
"    return ''
"  endif
"  " Get 'ls' output as a string
"  let ls_output = '' | redir =>> ls_output | silent! ls | redir END
"  " Match with quicklist string identifier
"  let matches = matchlist(ls_output, '\n\s*\(\d\+\).\{-,10}\[.\{-,10}Quickfix')
"  return (!empty(matches) && (empty(bufselect) || bufnr(bufselect)==matches[1]) ? 'c' : 'l')
endfunction

" User commands
command! -nargs=0 -bar Copen    bot copen 8
command! -nargs=0 -bar Cclose   cclose
command! -nargs=0 -bar Ctoggle  if s:Qtype('')==?'c' | Cclose | else | Copen | endif
command! -nargs=0 -bar Cnext    call s:Wnext('c')
command! -nargs=0 -bar Cprev    call s:Wprev('c')
command! -nargs=+ -bar Csys     call s:Wsys('c',<f-args>)
command! -nargs=+ -bar Ccmd     call s:Wcmd('c',<f-args>)

" Keymapping
nnoremap <localleader>c   :Ctoggle<CR>
nnoremap <silent>c        :Cnext<CR>
nnoremap <silent>C        :Cprev<CR>

" Autocommands
"if has('quickfix')
"  autocmd! QuickFixCmdPost [^l]* nested Copen
"endif


" *******************************************************
" } Location window management {
" *******************************************************

" User commands
command! -nargs=0 -bar Lopen    bot lopen 8
command! -nargs=0 -bar Lclose   lclose
command! -nargs=0 -bar Ltoggle  if s:Qtype('')==?'l' | Lclose | else | Lopen | endif
command! -nargs=0 -bar Lnext    call s:Wnext('l')
command! -nargs=0 -bar Lprev    call s:Wprev('l')
command! -nargs=+ -bar Lsys     call s:Wsys('l',<f-args>)
command! -nargs=+ -bar Lcmd     call s:Wcmd('l',<f-args>)

" Keymapping
nnoremap <localleader>l   :Ltoggle<CR>
nnoremap <silent>l        :Lnext<CR>
nnoremap <silent>L        :Lprev<CR>

" Autocommands (note: ltag is not concerned...)
"if has('quickfix')
"  augroup location_wnd
"    autocmd! QuickFixCmdPost * nested Lopen
"    autocmd! QuickFixCmdPost * nested call setqflist(getloclist(0))
"  augroup END
"endif


" *******************************************************
" } Tags {
" *******************************************************
" Set tags root
let g:tags_db='tags'
"set tags=./tags,tags;$HOME
set tags=./tags;$HOME

" User commands
command! -nargs=0 -bar Tnext    call s:Wnext('t')
command! -nargs=0 -bar Tprev    call s:Wprev('t')
command! -nargs=0 -bar Ttag     execute 'ltag' expand('<cword>') | call setqflist(getloclist(0))

" Key mapping
noremap <C-ENTER>           :Ttag<CR>
noremap <C-BACKSPACE>       <C-t>
nnoremap <silent>t          :execute (&previewwindow ? 'P' : 'T').'next'<CR>
nnoremap <silent>T          :execute (&previewwindow ? 'P' : 'T').'prev'<CR>

" Change root directory once at startup
if !exists('g:loaded_vimrc')
	execute 'cd' g:FindRootDir()
endif


" *******************************************************
" } Preview window {
" *******************************************************
" Options
set previewheight=12          " Preview window height

" Variables
if !exists('s:p_lastw')
	let s:p_lastw = ""
	let s:p_highlight = 0
	let s:p_center = 0
endif

" Open preview window
function! s:PreviewOpenWnd()
	silent! execute "bot pedit!"
	wincmd P
	if &previewwindow
		set nu
		"wincmd J
		wincmd p
	endif
	let s:p_lastw = ""
	augroup PreviewWnd
		au! CursorHold * nested call s:PreviewShowTag()
	augroup END
endfunction

" Close preview window
function! s:PreviewCloseWnd()
	augroup PreviewWnd
		au!
	augroup END
	pclose
	unlet s:p_lastw
endfunction

" Toggle preview window
function! s:PreviewToggleWnd()
	silent! wincmd P
	if &previewwindow
		wincmd p
		call s:PreviewCloseWnd()
	else
		call s:PreviewOpenWnd()
	endif
endfunction

function! s:PreviewShowTag()
	if &previewwindow             " don't do this in the preview window
		return
	endif
	let w = expand("<cword>")     " get the word under cursor
	if w == s:p_lastw             " Same word, skip all this
		return
	endif
	let s:p_lastw = w
	if w =~ '\a'                  " if the word contains a letter
		" Try displaying a matching tag for the word under the cursor
		try
			exec "silent! ptag " . w
			if s:p_highlight
				call s:PreviewHighlightTag(w)
			endif
			if s:p_center
				call s:PreviewCenterTag()
			endif
		endtry
	endif
endfunction

function! s:PreviewCenterTag()
	silent! wincmd P            " jump to preview window
	if &previewwindow           " if we really get there...
		normal! zz              " Center
		wincmd p                " back to old window
	endif
endfunction

function! s:PreviewHighlightTag(pattern)
	silent! wincmd P            " jump to preview window
	if &previewwindow           " if we really get there...
		match none              " delete existing highlight
		if has("folding")
			silent! .foldopen   " don't want a closed fold
		endif
		call search("$", "b")   " to end of previous line
		let w = substitute(a:pattern, '\\', '\\\\', "")
		call search('\<\V' . w . '\>') " position cursor on match
		" Add a match highlight to the word at this position
		hi previewWord term=bold ctermbg=blue guibg=blue
		exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
		wincmd p                " back to old window
	endif
endfunction

" User commands
command! -nargs=0 -bar Popen    call s:PreviewOpenWnd()
command! -nargs=0 -bar Pclose   call s:PreviewCloseWnd()
command! -nargs=0 -bar Ptoggle  call s:PreviewToggleWnd()
command! -nargs=0 -bar Pnext    call s:Wnext('pt')
command! -nargs=0 -bar Pprev    call s:Wprev('pt')
command! -nargs=0 -bar Ptag     call s:PreviewShowTag()

" Key mapping
nmap <localleader>p             :Ptoggle<CR>


" *******************************************************
" } The end
" *******************************************************

