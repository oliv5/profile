*******************************************
# Test the type of shell
# see http://www.saltycrane.com/blog/2008/01/how-to-scroll-in-gnu-screen/
[[ $- = *i* ]] && echo 'Interactive' || echo 'Not interactive'
shopt -q login_shell && echo 'Login shell' || echo 'Not login shell'

*******************************************
**** Loops on filenames, xargs, for, while
##### xargs -0
find . -type f -print0 | xargs -0 -r echo

##### For (not recommended)
(
IFS=$(printf " ")
for FILE in $(find . -type f -print); do
	echo "file=$FILE"
done
)

##### While
# Good
find . -type f -print0 | while IFS="" read -r -d "" FILE ; do
	echo "$FILE"
done

# Good
while IFS=: read userName passWord userID groupID geCos homeDir userShell; do
	echo "$userName -> $homeDir"
done < /etc/passwd

# Good
while IFS= read -r f <&3; do
	echo "$f"
done 3< delete.txt

# All '\n' are replaced by \0 => not good when in the middle of filename
mycommand | tr '\n' '\0' | while IFS="" read -r -d "" FILE ; do
	echo "$FILE"
done

**** Loops with no strange characters
# Bash only
while read -r -d" " f; do echo $f; done <<< $(env)

# Dash too
env | while read -r f; do echo $f; done

*******************************************
Setting Positional Parameters

Letting the caller set the positional parameters, by giving parameters on commandline, is not the only way to set them. The set builtin command can be used to "artificially" change the positional parameters from inside the script or function:

set "This is" my new "set of" positional parameters
# RESULTS IN
# $1: This is
# $2: my
# $3: new
# $4: set of
# $5: positional
# $6: parameters
It's wise to signal "end of options" when setting positional parameters this way. If not, dashes might be interpreted as option tag by set itself:

# both ways work, but behave differently. See the article about the set command!
set -- ...
set - ...

*******************************************
